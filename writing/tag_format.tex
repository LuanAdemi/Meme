\section{Encoding Unordered Attributes} 
\label{sec:flextag_encoding} 
In this section, we will first present a strawman tagging scheme that uses
wildcard matching to optimally minimize the number of forwarding table
entries needed to read flow attributes. We will then modify this strawman
such that it becomes feasible in commodity switches, at the cost
of slightly increased forwarding table memory usage.

%To understand the problem, let us consider a
%simple example for the case of attaching lists of anycast hosts to a packet. Say
%that there is a local area network with five hosts $H = \{h_1, h_2, h_3, h_4,
%h_5\}$, and each packet that arrives will be classified as anycasting to one of
%four possible host sets: $s_1 = \{h_1, h_2\}$, $s_2 = \{h_1, h_2, h_3\}$, $s_3 =
%\{h_1, h_3\}$, or $s_4 = \{h_3, h_4, h_5\}$. In a flat tagging solution to this
%problem, each unique set will be assigned a single tag, and thus a packet which
%can be forwarded to the $i^{th}$ set will receive the $i^{th}$ tag. Now, for an
%intermediate switch to determine, using exact tag matches, if a packet can be
%forwarded to host $h_1$, it must check whether the packet has been assigned to
%$s_1, s_2,$ or $s_3$. The number of entries required is proportional to the
%number of sets which contain $h_1$, in this case 3. In the worst case $h_1$
%would be a member of almost every group, and testing for $h_1$ would required a
%number of checks linear in the number of tags. 


\subsection{Strawman Bitmask Tags}
\label{ssec:bitmasks}
Assume that it is possible to attach an arbitrarily
large tag to each packet the moment it is classified, and that network switches
can perform masked matching on this tag.
We can easily use this hypothetical tag to encode and decode 
any attribute. If there are $N$ possible attributes, we can write $N$ bits to
the tag: the $i^{th}$ bit corresponds to the $i^{th}$ attribute. The moment
the packet is classified, the $i^{th}$ bit is set to 1 if the $i^{th}$ attribute
is true for that flow, and 0 if it is not. As a result, if we wish to test for
the presence of attribute $x$, we need only check that $x$'s bit is 1 in the
metadata before rerouting, rather than exact matching on every tag that contains
$x$.

Of course, we cannot attach arbitrary metadata to packets. Rather, we can
repurpose a field in the header for tagging. In FlowTags, the Fragment
Identification field is used. In SDX, the destination MAC stores the tags. And in Alpaca,
the suffix of the IPv4 source address is used. In
all cases, there is a hard limit on the size of tags to at most a few bytes.
The strawman of creating a bitmask to encode a set of attributes will fail the
moment the universe of attributes grows too large.


\subsection{Multiple Masked Sets}
\label{ssec:mset}

The strawman bitmask tags do not scale to any reasonable size, but they are 
a good starting point. The bitmask approach encodes the complete list
of attributes in a format that is easy to read using matching actions, and we aim to
maintain this property.
 


\begin{figure}[t!] \begin{minipage}{1\linewidth}
\begin{subfigure}[b]{0.96\linewidth} \includegraphics[trim={0 0 5.5cm 0}, clip,
width=\linewidth]{figures/masking} \end{subfigure}
\begin{subfigure}[c]{0.96\linewidth} \includegraphics[trim={0 13cm 5.5cm 0},
clip, width=\linewidth]{figures/making_metadata} \end{subfigure} \end{minipage}
\caption{Two different ways to recover attribute sets.
In (a), the sets are recovered by masking over $[A,B,C,D,E]$. In (b), the sets
are recovered by masking over either superset $[A,B,C]$ or set $[C,D,E]$. An X
denotes that the set cannot be fully recovered by masking over the given set.
(c) shows how the matrix in (b) can be mapped to tags.}
\label{fig:masking} \end{figure}

Consider the example in figure \ref{fig:masking}(a), where the left matrix
contain the lists of attributes that we wish to recover, and the right matrix
shows the bitmasks the strawman generates, which have a width of 5. Figure
\ref{fig:masking}(b) shows that the attributes can be broken up into two
categories: those which can be generated by masking over the superset $[A,B,C]$,
and those which can be generated by masking over $[C,D,E]$. If we can add to our
tag an identifier of the superset over which we are masking, we can have a
reduced mask size! As shown in figure \ref{fig:masking}(c), if superset
$[A,B,C]$ is identified as superset $0$, and $[C,D,E]$ is identified as superset
$1$, then the tag for a packet $p_4$ which is mapped to set $[C,D]$ becomes
$1110$, which is shorter than simply masking over the complete universe.

Now, if a switch wishes to test for attribute $D$, it must simultaneously check
(1) the identifier for the superset that contains $D$ and (2) the bit in the
bitmask which corresponds to $D$. Thus, the check that would be generated is\\
\noindent {
%\footnotesize 
$\texttt{tag=1*1*} \rightarrow
\texttt{action}(\AA)$\\ } 
Where the first bit in the tag match is for
the superset identifier, and the remainder is for the mask.

%\subsection{Merging Sets To Minimize Memory} \begin{algorithm} \caption{Greedy
%Memory Minimization}\label{alg:memory_min} \begin{algorithmic}[1]
%\Procedure{GreedyMin}{$S, O_W, W_{max}$} \While{$|S| > 1$} \State
%$bestPair\gets (None, None)$ \State $bestGain\gets 0$ \For{$(s_i, s_j) \in
%S\times S$} \State $S_{temp} \gets (S-\{s_i, s_j\}) \cup \{s_i\cup s_j\}$
%\If{$O_W(S_{temp}) \le W_{max}$} \State $gain \gets \sum_{k \in s_i\cap
%s_j}q_k$ \If{$gain > bestGain$} \State $bestGain \gets gain$ \State $bestPair
%\gets (s_i, s_j)$ \EndIf \EndIf \EndFor \If{$bestPair = (None, None)$} \State
%break \EndIf \State $(s_a, s_b) \gets bestPair$ \State $S \gets (S-\{s_a,
%s_b\}) \cup \{s_a\cup s_b\}$ \EndWhile \State \textbf{return} $S$ \EndProcedure
%\end{algorithmic} \end{algorithm}


\subsection{Merging Sets To Minimize Memory}
\label{ssec:merge}




\begin{algorithm}
\DontPrintSemicolon
\KwData{Supersets $\SS$, Tag Width Oracle $O_W$, Width Limit $W_{max}$.}
\KwResult{Supersets $\SS$ with minimal memory usage.}
\Begin{
\While{$|\SS| > 1$}{
      	$bestPair \gets (None, None)$\;
      	$bestGain\gets 0$\;
      	\For{$(s_i, s_j) \in \SS\times \SS$}{
      		$\SS_{temp} \gets (\SS-\{s_i, s_j\}) \cup \{s_i\cup s_j\}$\;
      		\If{$O_W(\SS_{temp}) \le W_{max}$}{
      			$gain \gets \sum_{k \in s_i\cap s_j}q_k$\;
      			\If{$gain > bestGain$}{
      				$bestGain \gets gain$\;
      				$bestPair \gets (s_i, s_j)$\;
      			}
      		}
      	}
      	\If{$bestPair = (None, None)$}{
      		\textbf{break}\;
      	}
      	$(s_a, s_b) \gets bestPair$\;
      	$\SS \gets (\SS-\{s_a, s_b\}) \cup \{s_a\cup s_b\}$\;
      }
      \textbf{return} $\SS$\;
}
\caption{Greedy Memory Minimization\label{alg:memory_min}}
\end{algorithm}


This tag format allows us to test for the presence of many attribute tag using
only a single matching string in switch memory.  However, this is not true for
all attributes. Looking again at figure \ref{fig:masking}(b), the case of
testing for attribute $C$ is not so simple. Since $C$ appears in both supersets,
we must check whether $C$'s bit is 1 in either superset mask. For example, if we
had the rule\\ 
\noindent {
%\footnotesize 
$\texttt{C in tag} \rightarrow
\texttt{action}(\AA)$\\ } 
This would be augmented under our scheme to
become\\ 
\noindent{
%\footnotesize 
$\texttt{metadata=0**1} \rightarrow
\texttt{action}(\AA)$\\ $\texttt{metadata=11**} \rightarrow
\texttt{action}(\AA)$\\ } 
Therefore, depending upon the matrix
construction, attribute tests may still require multiple forwarding table
entries. We refer to this effect as inflation. In the Figure
\ref{fig:masking}(b) example, we can eliminate inflation by merging the
supersets $[A,B,C]$ and $[C,D,E]$ into $[A,B,C,D,E]$. No attribute will appear
in multiple sets, but the tag size has increased from 4 to 5 bits (the mask went
from 3 to 5, and the identifier size went from 1 to 0).

In general, if an attribute $a$ is tested $q_a$ times and appears in $k_a$
supersets, there will be $q_a\cdot k_a$ match-action table entries for that
attribute. If we have a set of supersets $\SS = \{s_1, s_2, \dots, s_N\}$, we
can attempt to minimize the amount of memory we will use by replacing some pair
of sets $\{s_i, s_j\}$ in $\SS$ with their union $s_i\cup s_j$. If we do this,
note that the memory used will decrease by $\sum_{a \in s_i\cap s_j}q_a$,
because every attribute $a$ in the intersection of $s_i$ and $s_j$ will appear
in one less superset, eliminating $q_a$ tests from memory. We can extend this
observation to a simple greedy algorithm, which repeatedly finds a pair of
supersets to merge which maximally decreases overall memory usage until any
merging operation would case the maximum tag width to be exceeded. 


Algorithm \ref{alg:memory_min} shows this simple greedy memory minimization
algorithm in its entirety. The algorithm takes as input a superset list $\SS =
\{s_1, s_2, \dots, s_N\}$, a tag width oracle $O_W$ where $O_W(\SS)$ is the
number of tag bits required by list $\SS$ , and a maximum tag width $W_{max}$.
We use an oracle for computing the tag width consumed by our encoding because,
in a later section, a further modification to our encoding scheme makes
computing the tag width non-trivial. 

We have not stated which superset list $\SS$ to use as an input to our
algorithm. It suffices to begin with any list such that, for every attribute set
$A_i$ in the list of sets we need to encode, there is some superset $s_j \in
\SS$ such that $A_i \subseteq s_j$. An obvious choice for $\SS$ is to take the
list of attribute sets we wish to reproduce as our initial superset list. Note
that there may be many pairs of attribute sets $(A_i, A_j)$ such that $A_i
\subseteq A_j$. There is no reason to keep $A_i$ in $S$ in this case, so we
pre-process $\SS$ by removing any attribute set which is a subset of any other. 