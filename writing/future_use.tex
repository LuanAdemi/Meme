\section{Future Use}

We will end with speculation about applications of the encoding scheme. In our problem setting at a high level, some actor attaches a list of boolean statements to each packet before it enters a layer-2 network. Once the packet has entered the network, forwarding table entries are able to quickly check for and react to the truth of any specific statement with only a small number of entries. 

In our context, the actor which attaches the list of true statements is the SDN controller (indirectly), by relaying the metadata to be attached as a MAC to the participant border routers. The list of boolean statements is the list of valid routes, as advertised by BGP. If a bit is 0 or not present in the metadata, the statement is assumed to be false, or in other words the route is assumed to be invalid.

There are several properties that must be present for this scheme to work well. In order for the scheme to function at all, no list of statements must be too large, and there must be a large amount of redundancy in the possible lists of statements: many lists must be improper subsets of other lists. This is true in our setting because each list corresponds to participants which advertise some prefix, and many prefixes are announced by identical small sets of participants. 

An additional property that is worth note is that OpenFlow does not yet support masked writing, only masked reading. Because of this, the list of statements cannot be partially modified as it traverses the network. Instead, it must be either be fully overwritten or left unmodified while in the core. However, end hosts are of course able to modify the set one bit at a time, so long as they are able to modify individual, arbitrary bits of the ethernet fields.

We also cannot forget that the metadata is composed of a column identifier, mask, and ``mini MAC". The number of bits which must be allocated for the mini MAC is logarithmic in the number of nodes in order for each node to have a unique address. Formally, for the scheme to work, if you have X non-subset statement lists where the largest list is length Y, and you have Z nodes in your network, then it must be the case that 
$\log_2{X} + Y + \log_2{Z} \le 48$

One example to which our scheme could apply would be selective anycast in a local network. If a flow could be accepted by any single host in a specified set of hosts, the set could be encoded with our scheme. Switches in the network could check this set and choose any output port which leads to one of the hosts in the set.

Another example is encoding an unordered list of network functions which a flow should traverse before it reaches its destination. If a switch sees that a boolean in the metadata is true for a nearby network function, it could forward the flow to that function. Once the function has processed the flow, it could then flip the boolean to false. This is only possible for network functions implemented as hosts which can modify arbitrary bits in the header; the network functions could not be on current switches or hardware routers.

Although maybe without real motivation, these are just examples showing that any problem which fits the mold of encoding a set can be solved by our encoding scheme, if the required properties hold. 

