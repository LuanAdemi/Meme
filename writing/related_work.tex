\section{Related Work} \label{sec:related}
Alpaca~\cite{alpaca} also aims to embed attributes of each flow into the packet header with the goal of easing network policy enforcement, but does not follow the FEC tagging abstraction. Instead, they embed attributes into the hosts' IP address assignments, which adds the constraint that attribute encodings must be unique for each host. 

Flowtags~\cite{flowtags} uses flat tagging to associate each packet with a source host and a middlebox path, even in the face of middleboxes which modify packet headers. Their approach relies upon modifications of the source code of each middlebox to be able to read and write the tags. Our approach allows middleboxes to be unaware of tags, but at the cost of having no source host association which is readable by middleboxes. Tags are attached to packets by the first middlebox that the packets traverse. This implies that the packets must be steered to the first middlebox by some other means. Rules for decoding the tags are installed reactively as network nodes see tags for the first time. 

The SDX~\cite{sdx} project uses flat tagging to attach to packets a list of valid next-hops that packets can take through an internet exchange point . This list is then used to correctly enforce interdomain SDN policies that exchange point members install themselves. Tags are attached to packets by controller responses to ARP requests with tags as the destination MAC addresses. Rules for decoding the tags are installed proactively in the exchange point fabric.

SDX was followed by the iSDX~\cite{isdx} project, which aimed to address some of the scalability challenges that the first project faced. Namely, the number of rules needed to decode tags was prohibitively large in SDX, preventing any reasonably-sized IXP from implementing the project on commodity switches. One of the key changes that the iSDX project made to improve scalability was the introduction of a new tagging scheme which utilized wildcard matching. This tagging scheme is the precursor to our work. The tag attachment and decoding model mimicked the first SDX.

Bloom filter~\cite{Bloom} is a popular data structure for set representation. It supports membership queries and relies on a bit array. Bloom filter suffers from an inherent false positive error, where some elements can be wrongly reported as members of the set. While minimizing the tag width is an key property of our scheme, the Bloom filter memory is several times larger than the number of elements, e.g. 10-20 times for a false positive probability of 0.01\% - 1\%. Moreover, Bloom filter relies on hashing which might not be available in some switch architectures.