\section{Introduction}
\label{sec:intro}

Forwarding network traffic increasingly involves more sophisticated
forwarding operations than simply traversing a shortest path to a single
destination.  The values in a packet header may cause it to traverse a
sequence of middleboxes, be subject to various access-control policies,
or be forwarded to one of several distinct destinations. These types of
flexible forwarding decisions can require network switches to have many
forwarding table rules, each of which may match on multiple packet
header fields, thus causing switches to store many flow table entries to
handle all possible cases. Fortunately, although the number of possible
combinations of forwarding decisions could in theory result in an
inordinate number of flow table entries, in {\em practice} many distinct
traffic flows may be subject to the same forwarding actions and
policies, or {forwarding equivalence class} (FEC). Along an end-to-end
path, a switch could mark all packets that belong to the same FEC with a
tag that subsequent switches could use to make forwarding
decisions. Switches further downstream on the path could then make
forwarding decisions based on this tag, as opposed to a complex
combination of header fields, potentially reducing switch forwarding
table size if the number of FECs is smaller than the number of unique
header field combinations.

%%%
%%% FEC is an index
%%%
The simplest way to mark an FEC is with a flat tag.  MPLS~\cite{mpls}
and VLANs~\cite{vlan} use flat tags, for example, and newer SDN-based
architectures such as FlowTags~\cite{flowtags} and the original SDX
architecure~\cite{sdx} also make forwarding decisions based on flat
tags.  Flat tags work well in many scenarios because hardware switches
can perform exact matches on these fields; yet, forwarding tables that
match on flat tags do not scale, because the number of forwarding rules
that the switch must store grows linearly with the number of FECs which
traverse that switch, and small changes to forwarding decisions can
trigger recomutations of a large number of FECs (and tags).
%If a network node wishes to decode whether attribute $A$ is associated with a packet, it must determine whether the packet belongs to any FEC which is associated with $A$. If $A$ is associated with $N$ FECs, each of which has its own index, the switch requires $N$ rules for decoding $A$. 
In practice, an FEC constitutes a \emph{collection} of forwarding
decisions (\eg, a sequence of middleboxes), but two FECs that differ
only slightly would have completely different flat tags, making it
difficult to aggregate forwarding table rules.  For example,
Figure~\ref{fig:mbox_path} shows an example where an FEC constitutes a
sequence of middleboxes; two FECs may differ in only a single middlebox,
yet matching on flat tags requires the switch to maintain an entry for
each unique sequence. 

% Figure ~\ref{fig:mbox_path} shows a simple example of service chaining
% with four middleboxes, where every flow is mapped to one of four chains
% by some classification policy. To avoid reclassification at each switch,
% the figure shows a simple tagging scheme where each of the four paths
% receives a unique index tag. If the switches have up to date knowledge
% of which tag maps to which attribute set, reading the tag determines the
% next-hop. In flat tagging schemes, switches must have a rule for each distinct
%  tag they may see. In Figure ~\ref{fig:mbox_path}, the top set of switch
%  rules corresponds to flat tagging. No aggregation of these rules is
%  possible, as flat tagging schemes are based on exact matching rules.  
%  If the switches support more than just exact matching, these rules can
% be aggregated, as in the bottom set of switch rules. Where flat tagging
% can require rule space on the order of the number of tags,
% \emph{flexible tagging} can require as few as a constant action, as seen
% in in the figure where each next-hop has exactly one corresponding
% wildcard rule. Of course, this depends entirely upon how the tags are
% assigned. 




\begin{figure}[t!] 
\begin{minipage}{1\linewidth}
\includegraphics[trim={0 10cm 0 0}, clip, width=\linewidth]{figures/mbox_path_example}
\end{minipage} 
\caption{An illustration of the scaling issues of flat tagging. There are three switches $n_1, n_2, n_3$ and four middleboxes $A,B,C,D$. Packets enter the network on the left and are classified as needing to traverse one of four service chains, and are tagged as such. If flat matching is used, no aggregate rules are possible on the four tags.  }
\label{fig:mbox_path}
\end{figure}



%%%
%%% Capabilities of newer switches 
%%%
Instead, a forwarding mechanism that assigned tags that reflected
commonality between sequences or sets between different forwarding
equivalence classes could make it possible to aggregate forwarding table
entries in switchs.  Fortunately, commodity switches that support
OpenFlow~1.3~\cite{of13} can now perform {wildcard} matching on arbitrary
packet 
header fields; emerging protocol-independent switches supported by
languages such as P4~\cite{P4} will also support more flexible
matching based on wildcards. These new matching capabilities make it
possible to redesign FEC tagging architectures to achieve more efficient encodings.

In this paper, we take advantage of these emerging capabilities to
encode similar FECs with tags that share common bits, as opposed to
simply assigning each FEC a distinct flat tag.  These
\emph{attribute-carrying tags} are more compact and reduce forwarding
table size compared to flat tags.We present efficient algorithms for
encoding sets and sequences of attributes in tags amd demonstrate how
these encodings can reduce switch forwarding table size for a variety of
applications, including an SDN-based Internet Exchange Point and a
service chaining application. We have publicly released the source code
for the library that implements this encoding algorithm.

The rest of this paper proceeds as follows. Section~\ref{sec:motivation}
presents motivating applications. Section \ref{sec:flextag_encoding} presents
the basic ideas of our FEC encoding scheme. In Section \ref{sec:ordering}, we
extend our encoding to support ordered sequences of attributes; Section
\ref{sec:identifiers} improves the space efficiency of this encoding. In
Section \ref{sec:evaluation}, we evaluate the encoding over both real and
synthetic data sets. We discuss related work in Section
\ref{sec:related} and conclude in Section \ref{sec:conclusion}.






%\subsection{Common Ground}
%
%Although a diverse set of applications, each of these problems fits a common framework. As a packet enters a local area network, it is classified as belonging to some category of traffic. Associated with this category of traffic is a sequence or set. During classification, this sequence is somehow attached to the packet header.
%All three of these examples have a common framework: Packets are fit into categories as they enter a local area network, and associated with each category is some sequence of information. These sequences can be middleboxes, hosts, next-hop switches, or something else entirely. The sequence could be ordered, as in the case of middlebox paths, or unordered as in the case of feasible next-hops. In each case, the sequence is read by the local network switches to determine which direction to route the traffic. We refer to this reading of information as \textit{membership testing}, because routing choices are decided based upon which hosts or middleboxes are members of the sequence. 

%\subsection{Forwarding Table Matching On Tags}
%
%
%For this scheme of attaching information sets to packets to be feasible with commodity switches, it must be possible for membership testing to be implemented in the forwarding tables of switches. In switch TCAM tables, rules are are comparisons between a fixed string and the packet header, where the fixed strings are over the alphabet $\{0,1,*\}$. $0$ and $1$ are specific bit values, and $*$ denotes "don't care". We say that a packet header matches a string if for every bit in the header, either the bits are equal or one is a wildcard. Example usages include exact matches (strings with no wildcards), prefix matches (strings that end in wildcards), and reading of individual bits (strings with only one non-wildcard). 
%
%Various applications benefit from the use of TCAM 
%
% (TODO: cite some tagging works like flowtags and the original SDX?) have solved the problem of associating packets with information sets by generating a tag for each unique information set and repurposing one of the fields in the header for the tag. In the FlowTags work, each middlebox path had its own set of tags, which could fit into the IP Fragment Identification field. To determine if middlebox $X$ is the next-hop, switches must compare the tag to every tag which has $X$ as a next-hop using TCAM exact matches. This can result in a TCAM entry count exponential in the number of bits in a tag. In the SDX work, each set of next-hops had a unique tag which was placed in the destination mac field. Again, to determine if next-hop $X$ is correct, the tag must be compared against every tag which contains $X$ using exact TCAM matches. 
%
%In both works, the number of bits required can be quite small, but membership tests are expensive, requiring rules exponential in the tag size. TCAM is a very limited resource, and it would be desirable to design tags with the goal of decreasing the number of entries required for membership testing. 
%
%To combat these issues, we present a compression scheme which allows
%the encoding of sequences over a large number of elements, such as service chains or lists of BGP next-hops, into a format easily queried by commodity switches. We show how, with an additional algorithm, this scheme can be used to compress both ordered and unordered sets. Finally, we evaluate our algorithms across both synthetic and real datasets, and show not only does the number of bits needed by our compression scheme compete with the number of bits needed by tags, but that that each core switch need only a constant number of entries per membership test, versus a linear number of entries for the case of flat tagging.


