\section{Introduction}
\label{sec:intro}

Forwarding network traffic increasingly involves more sophisticated
forwarding operations than simply traversing a shortest path to a single
destination.  The values in a packet header may cause it to traverse a
sequence of middleboxes, be subject to various access-control policies,
or be forwarded to one of several distinct destinations. These types of
flexible forwarding decisions can require network switches to have many
forwarding table rules, each of which may match on multiple packet
header fields, thus causing switches to store many flow table entries to
handle all possible cases. Fortunately, although the number of possible
combinations of forwarding decisions could in theory result in an
inordinate number of flow table entries, in {\em practice} many distinct
traffic flows may be subject to the same forwarding actions and
policies, or {forwarding equivalence class} (FEC). Along an end-to-end
path, a switch could mark all packets that belong to the same FEC with a
tag that subsequent switches could use to make forwarding
decisions. Switches further downstream on the path could then make
forwarding decisions based on this tag, as opposed to a complex
combination of header fields, potentially reducing switch forwarding
table size if the number of FECs is smaller than the number of unique
header field combinations.

%%%
%%% FEC is an index
%%%
The simplest and most common form of FEC tag is a flat tag, or
\emph{index}.  MPLS~\cite{mpls} and VLANs~\cite{vlan} use flat tags, for
example, and newer SDN-based architectures such as
FlowTags~\cite{flowtags} and the original SDX architecure~\cite{sdx}
also make forwarding decisions based on flat tags.  Flat tags work well
in many scenarios because hardware switches can perform exact matches on
these fields; yet, forwarding tables that match on flat tags do not
scale, because the number of forwarding rules that the switch must store
grows linearly with the number of FECs which traverse that
switch, and small changes to forwarding decisions can trigger
recomutations of a large number of FECs (and tags).
%If a network node wishes to decode whether attribute $A$ is associated with a packet, it must determine whether the packet belongs to any FEC which is associated with $A$. If $A$ is associated with $N$ FECs, each of which has its own index, the switch requires $N$ rules for decoding $A$. 
In practice, an FEC constitutes a \emph{collection} of
forwarding decisions (\eg, a sequence of middleboxes), but two FECs that
differ only slightly would have completely different flat tags, making it
difficult to aggregate forwarding table rules.  For example,
Figure~\ref{fig:mbox_path} shows an example where an FEC constitutes a
sequence of middleboxes; two FECs may differ in only a single
middlebox. Instead, a forwarding scheme that assigned tags that
reflected this commonality could afford more opportunities for
aggregation.



\begin{figure}[t!] 
\begin{minipage}{1\linewidth}
\includegraphics[trim={0 10cm 0 0}, clip, width=\linewidth]{figures/mbox_path_example}
\end{minipage} 
\caption{An illustration of the scaling issues of flat tagging. There are three switches $n_1, n_2, n_3$ and four middleboxes $A,B,C,D$. Packets enter the network on the left and are classified as needing to traverse one of four service chains, and are tagged as such. If flat matching is used, no aggregate rules are possible on the four tags.  }
\label{fig:mbox_path}
\end{figure}



%%%
%%% Capabilities of newer switches 
%%%
Recently, commodity switches have emerged with more sophisticated capabilities, such as OpenFlow 1.3~\cite{of13} switches that supports \emph{wildcard} matching on previously flat header fields, and emerging protocol-independent switches (programmable using languages like P4~\cite{P4}) which support arbitrary headers that can be read, written, and matched in flexible ways.  These advances enable much more flexible ways to tag and match packets, beyond simple index tagging. 

%In the case of virtual circuit switching, the number of possible circuits can be exponential in the size of the network. Switches need to be programmed to react to every tag they may see, resulting in exponential memory usage. It may be the case that the majority of equivalence classes that a switch sees take identical egress ports, yet traditional tagging is unable to take advantage of this redundancy. Fundamentally, an equivalence class can be characterized by a set of attributes where that set is unique to that class. If two circuits differ by only a single hop, their attribute sets are unique and they are assigned different tags. Traditional solutions make no attempt to convey the similarity of the two sets in the tags, which could allow switches to be programmed with a single rule that reacts to both tags. We refer to these solutions as \textit{flat tagging} solutions. 


%Paragraph 3: "In this paper, we show that ...". This is the key paragraph in the intro - you summarize, in one paragraph, what are the main contributions of your paper given the context you have established in paragraphs 1 and 2. What is the general approach taken? Why are the specific results significant? This paragraph must be really really good. If you can't "sell" your work at a high level in a paragraph in the intro, then you are in trouble. As a reader or reviewer, this is the paragraph that I always look for, and read very carefully.

In this paper, we show how the set of attributes that define an
equivalence class can be encoded in the assigned tag. The attributes of
any tag can then be individually read using a small set of wildcard
rules.  Such \emph{attribute-carrying tags} are much more compact, and
lead to much smaller rule tables, than index tagging solutions.  We
present efficient algorithms for generating compact tags that represent
either \emph{sets} or \emph{sequences} of attributes.  We show how these
tags can be used to improve the scalability in several real
applications, including our SDN-based Internet exchange
point~\cite{isdx}.  We have made public the code library for
incorporating our tagging scheme into any application. We perform
evaluations on both real and synthetic datasets for our proposed
applications and show that it can reduce the amount of switch memory by
X.  

%Paragraph 4: At a high level what are the differences in what you are doing, and what others have done? Keep this at a high level, you can refer to a future section where specific details and differences will be given. But it is important for the reader to know at a high level, what is new about this work compared to other work in the area.

%Paragraph 5: "The remainder of this paper is structured as follows..." Give the reader a roadmap for the rest of the paper. Avoid redundant phrasing, "In Section 2, In section 3, ... In Section 4, ... " etc.

The remainder of this paper is structured as follows. In \S \ref{sec:background}, we give some area background and a few motivating applications. In \S \ref{sec:flextag_encoding}, we outline the basic ideas of our encoding scheme for attaching sets of attributes to packet headers. In \S \ref{sec:ordering}, we extend our encoding to support ordered sequences of attributes. In \S \ref{sec:identifiers}, we improve the space usage of the encoding. In \S \ref{sec:evaluation}, we evaluate the encoding over both real and synthetic data sets. We discuss related works in \S \ref{sec:related}. The paper concludes with \S \ref{sec:conclusion}.






%\subsection{Common Ground}
%
%Although a diverse set of applications, each of these problems fits a common framework. As a packet enters a local area network, it is classified as belonging to some category of traffic. Associated with this category of traffic is a sequence or set. During classification, this sequence is somehow attached to the packet header.
%All three of these examples have a common framework: Packets are fit into categories as they enter a local area network, and associated with each category is some sequence of information. These sequences can be middleboxes, hosts, next-hop switches, or something else entirely. The sequence could be ordered, as in the case of middlebox paths, or unordered as in the case of feasible next-hops. In each case, the sequence is read by the local network switches to determine which direction to route the traffic. We refer to this reading of information as \textit{membership testing}, because routing choices are decided based upon which hosts or middleboxes are members of the sequence. 

%\subsection{Forwarding Table Matching On Tags}
%
%
%For this scheme of attaching information sets to packets to be feasible with commodity switches, it must be possible for membership testing to be implemented in the forwarding tables of switches. In switch TCAM tables, rules are are comparisons between a fixed string and the packet header, where the fixed strings are over the alphabet $\{0,1,*\}$. $0$ and $1$ are specific bit values, and $*$ denotes "don't care". We say that a packet header matches a string if for every bit in the header, either the bits are equal or one is a wildcard. Example usages include exact matches (strings with no wildcards), prefix matches (strings that end in wildcards), and reading of individual bits (strings with only one non-wildcard). 
%
%Various applications benefit from the use of TCAM 
%
% (TODO: cite some tagging works like flowtags and the original SDX?) have solved the problem of associating packets with information sets by generating a tag for each unique information set and repurposing one of the fields in the header for the tag. In the FlowTags work, each middlebox path had its own set of tags, which could fit into the IP Fragment Identification field. To determine if middlebox $X$ is the next-hop, switches must compare the tag to every tag which has $X$ as a next-hop using TCAM exact matches. This can result in a TCAM entry count exponential in the number of bits in a tag. In the SDX work, each set of next-hops had a unique tag which was placed in the destination mac field. Again, to determine if next-hop $X$ is correct, the tag must be compared against every tag which contains $X$ using exact TCAM matches. 
%
%In both works, the number of bits required can be quite small, but membership tests are expensive, requiring rules exponential in the tag size. TCAM is a very limited resource, and it would be desirable to design tags with the goal of decreasing the number of entries required for membership testing. 
%
%To combat these issues, we present a compression scheme which allows
%the encoding of sequences over a large number of elements, such as service chains or lists of BGP next-hops, into a format easily queried by commodity switches. We show how, with an additional algorithm, this scheme can be used to compress both ordered and unordered sets. Finally, we evaluate our algorithms across both synthetic and real datasets, and show not only does the number of bits needed by our compression scheme compete with the number of bits needed by tags, but that that each core switch need only a constant number of entries per membership test, versus a linear number of entries for the case of flat tagging.


