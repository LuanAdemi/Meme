\section{Introduction}
\label{sec:intro}
%%%
%%% Forwarding Equivalence Class
%%%
Routing is increasingly more complicated than simply directing all traffic along a shortest path to the destination.  Depending on their header fields, packets may traverse a sequence of middleboxes, be subject to access-control policies, be multicast to a set of receivers, or be anycast to one of several equivalent servers.  Customizing the handling of the packets can require network switches to have a large number of forwarding rules that match on multiple header fields.  Fortunately, many packets are treated the same way.  Traffic flows that are treated identically by the network can be grouped into a single \textit{Forwarding Equivalence Class}. If the edge of the network classifies each packet and tags it with an FEC, the interior switches can simply forward packets based on the tag, leading to substantial reductions in forwarding state.

%%%
%%% FEC is an index
%%%
The simplest and most common form of FEC is a flat label, or \emph{index}. Historically, virtual circuit switching techniques like MPLS [cite MPLS] and VLAN [cite VLAN] follow this approach, and it is common in newer works as well (e.g., cite FlowTags, SDX).  Using the tag as an index worked well with traditional switch hardware that supports exact matches on a single header field, such as an MPLS label, VLAN tag, or destination MAC address.  However, index tagging solutions face scalability challenges, since the switches must have at least one rule for each label, and network events (such as topology changes) can require many of these rules to change.  Suppose a network has $N$ virtual circuits that follow different paths, where
$\frac{N}{2}$ circuits begin with nodes ABC, and $\frac{N}{2}$ begin with ABD. In the worst case, Node B will have to compare every packet's tag to at least $\frac{N}{2}$ tags to decide whether to forward to C or D, because it must exhaustively rule out one of the two classes. Fundamentally, the issue is that each equivalence class is characterized by a \emph{set} of attributes, yet two equivalence classes which differ by only one attribute receive arbitrary indices. For virtual circuits, the attributes are a list of hops, and the difference between two circuits can be a divergence at the end of the circuit.

%%%
%%% Capabilities of newer switches 
%%%
Recently, commodity switches have emerged with more sophisticated capabilities.  OpenFlow 1.3 [cite:openflow1.3] supports wildcard matching on multiple header fields. Emerging protocol-independent switches (programmable using languages like P4 [cite:p4]) support arbitrary headers that can be read, written, and matched in flexible ways.  These advances enable much more flexible ways to tag and match packets, beyond simple index tagging. [GIVE EXAMPLES]


%In the case of virtual circuit switching, the number of possible circuits can be exponential in the size of the network. Switches need to be programmed to react to every tag they may see, resulting in exponential memory usage. It may be the case that the majority of equivalence classes that a switch sees take identical egress ports, yet traditional tagging is unable to take advantage of this redundancy. Fundamentally, an equivalence class can be characterized by a set of attributes where that set is unique to that class. If two circuits differ by only a single hop, their attribute sets are unique and they are assigned different tags. Traditional solutions make no attempt to convey the similarity of the two sets in the tags, which could allow switches to be programmed with a single rule that reacts to both tags. We refer to these solutions as \textit{flat tagging} solutions. 


%Paragraph 3: "In this paper, we show that ...". This is the key paragraph in the intro - you summarize, in one paragraph, what are the main contributions of your paper given the context you have established in paragraphs 1 and 2. What is the general approach taken? Why are the specific results significant? This paragraph must be really really good. If you can't "sell" your work at a high level in a paragraph in the intro, then you are in trouble. As a reader or reviewer, this is the paragraph that I always look for, and read very carefully.

In this paper, we show how the set of attributes that define an equivalence class can be embedded in the assigned tag. The attributes of any tag can then be individually read using a small set of wildcard rules. These attribute-carrying tags, or a-tags, can decrease the amount of memory used by core switches by up to two orders of magnitude compared to index tagging solutions. We show how these tags can be used in several real applications, including one which has seen real-world deployment. Additionally, we show how these tags not only improve existing solutions, but also open new applications. We perform evaluations on both real and synthetic datasets for our proposed applications.



%Paragraph 4: At a high level what are the differences in what you are doing, and what others have done? Keep this at a high level, you can refer to a future section where specific details and differences will be given. But it is important for the reader to know at a high level, what is new about this work compared to other work in the area.



%Paragraph 5: "The remainder of this paper is structured as follows..." Give the reader a roadmap for the rest of the paper. Avoid redundant phrasing, "In Section 2, In section 3, ... In Section 4, ... " etc.

The remainder of this paper is structured as follows. In Section 2, we give some area background and a few motivating applications. In Sections 3 and 5, we build our solution in two stages. In sections 4 and 6, we discuss how to optimize the two stages of our solution. In section 7, we evaluate the solution over both real and synthetic data sets. The paper concludes with whatever filler we have space for.






%\subsection{Common Ground}
%
%Although a diverse set of applications, each of these problems fits a common framework. As a packet enters a local area network, it is classified as belonging to some category of traffic. Associated with this category of traffic is a sequence or set. During classification, this sequence is somehow attached to the packet header.
%All three of these examples have a common framework: Packets are fit into categories as they enter a local area network, and associated with each category is some sequence of information. These sequences can be middleboxes, hosts, next-hop switches, or something else entirely. The sequence could be ordered, as in the case of middlebox paths, or unordered as in the case of feasible next-hops. In each case, the sequence is read by the local network switches to determine which direction to route the traffic. We refer to this reading of information as \textit{membership testing}, because routing choices are decided based upon which hosts or middleboxes are members of the sequence. 

%\subsection{Forwarding Table Matching On Tags}
%
%
%For this scheme of attaching information sets to packets to be feasible with commodity switches, it must be possible for membership testing to be implemented in the forwarding tables of switches. In switch TCAM tables, rules are are comparisons between a fixed string and the packet header, where the fixed strings are over the alphabet $\{0,1,*\}$. $0$ and $1$ are specific bit values, and $*$ denotes "don't care". We say that a packet header matches a string if for every bit in the header, either the bits are equal or one is a wildcard. Example usages include exact matches (strings with no wildcards), prefix matches (strings that end in wildcards), and reading of individual bits (strings with only one non-wildcard). 
%
%Various applications benefit from the use of TCAM 
%
% (TODO: cite some tagging works like flowtags and the original SDX?) have solved the problem of associating packets with information sets by generating a tag for each unique information set and repurposing one of the fields in the header for the tag. In the FlowTags work, each middlebox path had its own set of tags, which could fit into the IP Fragment Identification field. To determine if middlebox $X$ is the next-hop, switches must compare the tag to every tag which has $X$ as a next-hop using TCAM exact matches. This can result in a TCAM entry count exponential in the number of bits in a tag. In the SDX work, each set of next-hops had a unique tag which was placed in the destination mac field. Again, to determine if next-hop $X$ is correct, the tag must be compared against every tag which contains $X$ using exact TCAM matches. 
%
%In both works, the number of bits required can be quite small, but membership tests are expensive, requiring rules exponential in the tag size. TCAM is a very limited resource, and it would be desirable to design tags with the goal of decreasing the number of entries required for membership testing. 
%
%To combat these issues, we present a compression scheme which allows
%the encoding of sequences over a large number of elements, such as service chains or lists of BGP next-hops, into a format easily queried by commodity switches. We show how, with an additional algorithm, this scheme can be used to compress both ordered and unordered sets. Finally, we evaluate our algorithms across both synthetic and real datasets, and show not only does the number of bits needed by our compression scheme compete with the number of bits needed by tags, but that that each core switch need only a constant number of entries per membership test, versus a linear number of entries for the case of flat tagging.


