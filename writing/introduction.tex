\section{Introduction}
In many situations, it is desirable to classify each packet as belonging to a certain category of traffic or mapping each packet to a set of properties as it enters a local area network. As an example, some packets may be classified as needing to traverse a firewall and a NAT, and some packets may have a set of valid anycast destinations. One approach is to attach to each packet during classification a tag or label which maps that packet to its selected category. These tags can then be used by network switches to make forwarding or policy decisions in the core of the network. To motivate the problem, we will give three examples.

Consider the example of an Internet Exchange Point (IXP) with support for SDN policies. At such an IXP, participants may wish to apply SDN policies to traffic as it enters the exchange point. We will refer to these policies as outbound policies. If these policies were not present, all traffic for some participant $P$ would be directed to the BGP default next-hop as decided by $P$. In the presence of outbound policies, however, traffic may be redirected to take a next-hop which differs from the BGP default next-hop. This redirection must be to a next-hop which has been announced to $P$, and the policies must take this into account. If it were possible to attach to each packet leaving $P$ with destination prefix $D$ the set of IXP participants which have advertised $D$ to $P$, outbound policies could check for the presence of a next-hop in the set before rerouting the packet to that next-hop. 


%For another example, recent works have shown interest in installing policies in whitebox switches across the network, reducing the need for proprietary middleboxes. These policies may be replicated across several whiteboxes for load balancing or other purposes. If this is the case, a packet which needs to hit some policy switch may have more than one valid whitebox destination. It may also be the case that the complete policy a packet must hit is distributed across multiple whiteboxes. In this case, the packet must traverse every whitebox in a set of whiteboxes. For both of these cases, each packet can be mapped to an unordered set of whiteboxes which can or must be traversed. For policies to be correctly applied to the packet, switches must take these sets into account when routing the packet. If the switches had knowledge of the set of whiteboxes which the packet has yet to hit, each switch could choose to forward the packet to the nearest box in the set.  

For another example, consider the case of anycast. In traditional anycast, many receivers are identified by the same address, and each anycast packet simply chooses the nearest receiver according to some distance metric. There is no flexibility for selecting arbitrary subsets of hosts without applying the same identifier to the subset of receivers. We envision the potential for a more flexible local area network anycast, where each packet can be mapped to an arbitrary subset of hosts, regardless of their addresses. If it were possible to tag each packet during classification with a list of host identifiers, switches could read this list and pick the nearest for forwarding.

In a third example, consider the setting of each packet hitting a different service chain of middleboxes. When a packet enters a network via an ingress switch, the ingress switch may decide during classification that the traffic must be steered through a chain of middleboxes before it exits the network or reaches its final destination. If the middleboxes are spread throughout the network, it can be difficult to ensure that the traffic traverses the middleboxes in the desired order. However, consider if it were possible to attach to each packet an list of middlebox identifiers, ordered left to right. The first middlebox along the path would be the leftmost identifier in the list, and switches could forward accordingly. If an identifier could be popped after hitting the appropriate middlebox, switches could simply always forward to the leftmost identifier in the list to correctly route a packet through a service chain. This could be accomplished with an MPLS label stack, but middleboxes do not necessarily understand or preserve MPLS labels. 

\subsection{Common Ground}

Although a diverse set of applications, each of these problems fits a common framework. As a packet enters a local area network, it is classified as belonging to some category of traffic. Associated with this category of traffic is a sequence or set. During classification, this sequence is somehow attached to the packet header.
All three of these examples have a common framework: Packets are fit into categories as they enter a local area network, and associated with each category is some sequence of information. These sequences can be middleboxes, hosts, next-hop switches, or something else entirely. The sequence could be ordered, as in the case of middlebox paths, or unordered as in the case of feasible next-hops. In each case, the sequence is read by the local network switches to determine which direction to route the traffic. We refer to this reading of information as \textit{membership testing}, because routing choices are decided based upon which hosts or middleboxes are members of the sequence. 

\subsection{Forwarding Table Matching On Tags}

For this scheme of attaching information sets to packets to be feasible with commodity switches, it must be possible for membership testing to be implemented in the forwarding tables of switches. In forwarding tables, rules are written as header matches against strings over the alphabet $\{0,1,*\}$, where $0$ and $1$ are exact matches, and $*$ denotes a 'wildcard' match. A packet header matches a forwarding table entry string if for every bit in the header, either the same bit in the entry is an exact match or a wildcard. Applications of these string matchings include exact matches (strings with no wildcards), prefix matches (strings that end in wildcards), and testing of individual bits (strings with only one non-wildcard). 

Various works (TODO: cite some tagging works like flowtags and the original SDX?) have solved the problem of associating packets with information sets by generating a tag for each unique information set and repurposing one of the fields in the header for the tag. In the FlowTags work, each middlebox path had its own set of tags, which could fit into the IP Fragment Identification field. To determine if middlebox $X$ is the next-hop, switches must compare the tag to every tag which has $X$ as a next-hop using TCAM exact matches. This can result in a TCAM entry count exponential in the number of bits in a tag. In the SDX work, each set of next-hops had a unique tag which was placed in the destination mac field. Again, to determine if next-hop $X$ is correct, the tag must be compared against every tag which contains $X$ using exact TCAM matches. 

In both works, the number of bits required can be quite small, but membership tests are expensive, requiring rules exponential in the tag size. TCAM is a very limited resource, and it would be desirable to design tags with the goal of decreasing the number of entries required for membership testing. 

To combat these issues, we present a compression scheme which allows
the encoding of sequences over a large number of elements, such as service chains or lists of BGP next-hops, into a format easily queried by commodity switches. We show how, with an additional algorithm, this scheme can be used to compress both ordered and unordered sets. Finally, we evaluate our algorithms across both synthetic and real datasets, and show not only does the number of bits needed by our compression scheme compete with the number of bits needed by tags, but that that each core switch need only a constant number of entries per membership test, versus a linear number of entries for the case of flat tagging.


