\section{Moving Beyond Flat Index Tags} \label{sec:background}
Packet labeling schemes need to work within the capabilities of commodity
switches. In this section, we first review packet forwarding in high-speed
switches and how the ``match-action'' capabilities have evolved in recent years.
Next, we discuss flat index tagging and its limitations, and then present
several example applications that would benefit from more flexible tagging
schemes.

\subsection{Match-Action Tables in Switches} 
\label{ssec:match-action}
Commodity switches traditionally
use \emph{match-action tables} to determine how to handle packets, based on
\textit{forwarding rules} installed at runtime. Each match ($M$) in the forwarding
rules is comprised of one or more matching conditions, where each of these 
matching conditions define the match string or a header field of packet $P$. 
We can represent this match string as $S \in \{0,1,*\}^{W_{field}}$, where
$W_{field}$ is the width of the designated header field. There are three types 
of matches in commodity switches:

\begin{itemize} 
\item \textbf{Exact Matching:} $S \in \{0,1\}^{W_{field}}$ is a
binary string, and $M(P) = true$ if $S = P[field]$.

\item \textbf{Longest-Prefix Matching:} $S$ is a ternary string, where the first $x$
characters are drawn from $\{0,1\}$ and the remaining are $*$. $M(P) = true$ if
the first $x$ characters of $S$ match the first $x$ characters of $P[field]$,
and there is no rule such that the first $y$ characters match for some $y > x$. 

\item \textbf{Wildcard Matching:} $S \in \{0,1,*\}^{W_{field}}$ is any
ternary string. Associated with each wildcard match is a priority. $M(P) = true$
if two conditions are met: (1)~For every $0 \le i < W_{field}$, either the
$i^{th}$ character of $S$ is $*$, or the $i^{th}$ character of $S$ matches
the $i^{th}$ character of $P[field]$. (2)~There is no other wildcard match
rule of higher priority that satisfies condition~(1).  
\end{itemize}
\noindent
Until recently, switches imposed significant restrictions on the matching type.
For the vast majority of fields, this matching type is exact matching, with the
exception of longest-prefix matching for IP addresses. Consequently, techniques
for tagging packets had to rely on flat labels.  However, with recent changes to
commodity switches, such as new features supported by OpenFlow 1.3
switches~\cite{of13} and flexible protocol-independent switches~\cite{P4},
we can apply longest-prefix or wildcard matching to many header fields, or
even define our own header fields for use within a single network.

\subsection{Forwarding Equivalence Class Tagging} 
\label{ssec:fec-tagging}
In flat tagging schemes, the
tag serves as a single, unstructured index.  A flow of packets is defined by a
combination of header fields that each of the packets has in common. Each
combination of header fields can imply a set of attributes which are revealed by
classification, such as a set of routes the flow may take, middleboxes the flow
must traverse, or permissions of the sending/receiving hosts which are read by
security policies.  Figure ~\ref{fig:mbox_path} shows the concrete example of
service chains. Every flow has a set of middlebox functions it must traverse,
determined by some network policy.

Switches must be aware of these attributes to correctly implement a policy. In
our example, not all flows should traverse switch $E$. To determine which flows
to route through the NAT, each switch could re-perform classification. However,
the number of rules may be prohibitively large to install on each switch.  

To avoid repeatedly classifying the packets, the result can be represented as a
short \textit{tag} attached to each packet. Switches may then read these tags to
discover the attributes. If we maintained global knowledge of every distinct set
of attributes in an array, we could then use the array indices as packet tags
and provide each switch with the index-to-attributes mapping. This mapping is
shown in the second table of figure MISSING. Switches can then recover all
attributes by reading the tag.

%However, a good format for these digests which minimizes both the digest size
%and read operation complexity is unclear. 

This tagging scheme is optimal in tag width, because it uses the minimum number
of bits to convey the attribute set for each flow. However, small tags comes at
the cost of complexity in reading the attributes.  To make a decision based only
on attribute $x$, a switch must compare each packet's tag to the indices of
every set that contains attribute $x$. In our example, the Load Balancing
middlebox is present in three tags, so switches must compare the packet's tag to
each of the three tags to determine if the middlebox is in the attribute set. In
general, if the number of attribute sets is large enough, this tagging scheme
may barely improve upon the memory used by performing re-classification at every
switch!

% TODO: Either figure out better place to use this figure or nix it completely.
%\begin{figure}[t!] \begin{minipage}{1\linewidth} \includegraphics[trim={0 8cm 0
%0}, clip, width=\linewidth]{figures/system_flow2} \end{minipage} \caption{An
%illustration of the information flow for an attribute-encoding tagging scheme.}
%\label{fig:system_flow} \end{figure}

Attribute reading need not be so complex, though. If we do not require minimal
tag width, we can make the attributes much easier to read. Figure BLANK shows
such a construction for service chains, with tags as bit fields. Each attribute
can be read using a single wildcard match, but the tag width is equal to the
number of middleboxes. It is interesting to note that when each bit-field tag is
viewed as an integer, it can still be thought of as an index into a implicit
table of all possible attribute sets. 

In general, any tagging scheme must simultaneously minimize three different
metrics: \begin{enumerate} \item \textbf{Tag Width:} Tags should not be too
wide, to avoid wasting packet-header space.  Tags should be able to either be
inserted into small repurposed header fields or contribute little size to custom
packet headers.  \item \textbf{Switch Memory:} The amount of memory required to
decode attributes from any tag should be able to easily fit in modern commodity
switches.  \item \textbf{Churn:} No network event should cause the encoding
scheme to generate too many control messages.  \end{enumerate}
%It is these metrics by which we will evaluate our solution.
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Motivating Applications} 
\label{ssec:motivating-apps}

\begin{figure} \small \begin{center}
\begin{tabular}{|l|c|c|} \hline \multicolumn{1}{|c|}{\bf Application} &
\multicolumn{1}{c|}{\bf FEC Attributes} & \multicolumn{1}{c|}{\bf Ordered?}\\
\hline SDN-enabled IXP & Advertising peers & No \\ \hline Service chaining &
Middleboxes & Yes \\ \hline Policy enforcement & Host permissions & No \\ \hline
Multicast/anycast & Servers & Maybe \\ \hline \end{tabular} \end{center}
\caption{Example applications and their relevant properties. }
\label{tab:applications} \end{figure}

There are many applications where a forwarding equivalence class is
characterized by a distinct set of attributes, and where the switches could
benefit from being able to read these sets using a small amount of memory. To
motivate our solution, we will present four such applications, which are
summarized in Figure \ref{tab:applications}.
 
\paragraph{Software-Defined Internet Exchange Points} Consider the example of an
Internet Exchange Point (IXP) with $N$ members Autonomous Systems $[AS_1, AS_2,
..., AS_N]$ and support for participants to install fine-grained forwarding
policies on the shared fabric. At such an IXP, members may wish to enact
\textit{Application-Specific Peering}, where traffic exchange is determined by
header fields other than the destination IP address. Say that $AS_1$ wishes to
send as much of their HTTP traffic to $AS_2$ as possible. $AS_2$ does not have
routes to every HTTP destination, so it is incorrect for them to receive all
HTTP traffic. This peering policy could be augmented to only apply if the
packet's destination is from the set of destinations that $AS_2$ advertises, but
this would greatly increase the memory required. If instead every packet that
entered the exchange point was tagged with the set of IXP members that have
routes towards the packet's destination, $AS_1$'s peering policy could easily
check the packet header for the presence of $AS_2$ before forwarding.

\paragraph{Service Chaining} Network operators often desire that network traffic
be directed through a series of middleboxes, such as load balancers or
firewalls. Such middleboxes can provide security and performance guarantees for
the network's users.  However, each flow may need to be directed through a
different chain of middleboxes. If each packet header had a list of middleboxes
to visit, switches could check for the presence of a middlebox in the header
and, if present, forward that packet towards the nearest matching middlebox.
This resembles source routing or virtual circuit switching and could be
accomplished with an MPLS label stack, but middleboxes do not necessarily
understand or preserve MPLS labels. 

\paragraph{Host Attributes for Network Policies} Network policies may require
knowledge of properties of the sending or receiving hosts in order to be applied
correctly. As an example, users in the Computer Science department may be
blocked from communicating with users in the Plasma Physics lab, because they
are chumps. Since this information is not attached to the packets directly, it
must be inferred from the source and destination addresses. This can result in a
costly cross-product of matching conditions for enacting the policy. If each
packet had a set of flags which directly correspond to these attributes, policy
enforcers could simply check the two flags simultaneously. 


\paragraph{Multicast and Anycast} In a classic IP anycast scenario, a single
service is replicated across multiple servers to attempt to lighten the maximum
load that any single server receives. Since each server hosts the same server,
they can all equivalently handle packets destined for that service. Each server
is assigned the same IP address, and the network forwards any traffic destined
for the shared IP address to the nearest replica of the service. However, if
each server has a set of services it replicates, but sets differ across
servers, no two servers can be treated equally and receive identical IP
addresses. If lists of servers could be attached to packet headers, the
network could read this list and choose a server to handle the packet. The
scenario of Multicast is similar, where a list of subscribers can be
attached to the packet header of a multicast packet. The network would then
read this list and replicate the packet towards each subscriber. 
