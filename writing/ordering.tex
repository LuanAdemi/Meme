\section{Encoding Attribute Sequences}
\label{sec:ordering}


\begin{figure*}[t!]
%\begin{minipage}{2\linewidth}
%\begin{subfigure}[c]{0.96\linewidth}
%\includegraphics[trim={0 6cm 19.2cm 0}, clip, width=\linewidth]{figures/partial_ordering}
\includegraphics[trim={0 18cm 0 0}, clip, width=\textwidth]{figures/partial_ordering2}
%\end{subfigure} 
%\end{minipage} 
\caption{Not-aligned ordering constraints. (a) shows the four input ordered sequences. (b) illustrates the corresponding sequence graph $G$ (c) shows the disjoint SCCs  (Strongly Connected Components) of $G$. Each SCC corresponds to a set of incomparable elements. In (d), we order the elements of the SCC to minimize backward edges. (e) and (f) show how nodes of the SCC can be split to make all backward edges become forward edges, allowing a complete ordering to be found. Splitting nodes results in duplicated elements, which slightly changes the original sequences, as shown in (f).}
\label{fig:ordering}
\end{figure*}

In some applications, the \emph{order} of attributes is important.  For example, in service chaining, traffic must traverse middleboxes in a specified order.  In this section, we extend our scheme for encoding \emph{sets} of attributes to support \textit{sequences} of attributes.  We first propose a simple representation of the attribute sequences in a sequence graph.  Next, we discuss how to encode sequences when the attributes follow a partial order.  Then, we show how to encode sequences in general, even when the attributes do not form a partial order.

\subsection{Sequence Graph of Attribute Orderings}
When the tag must encode a sequence of attributes, we need an effective way to identify what \emph{ordering} of attributes can occur.  Figure~\ref{fig:ordering}(a) shows four equivalence classes ($S_1$-$S_4$) with different sequences of attributes ($A$-$F$); for example, $S_2$ has the attribute sequence $E$-$A$-$B$, whereas $S_4$ has $A$-$B$-$C$-$D$.  We can generate a \emph{sequence graph} where each node is an attribute, and a directed edge from node $u$ to node $v$ exists if $u$ appears just before $v$ in any of the sequences.  For example, the sequence graph in Figure~\ref{fig:ordering}(b) has an edge from $E$ to $A$ and from $A$ to $B$ because of $S_2$, and from $D$ to $F$ because of $S_3$.  Each sequence in the input data corresponds to a path through the sequence graph.  If the sequence graph is acyclic, the attributes form a partial order, making it easier to encode all of the the sequences concisely.

\subsection{Sequences Forming a Partial Order}
If all of the attributes form a (partial) order, we can easily construct a single ordered list of all attributes where each input sequence is a subsequence. We refer to such a sequence as a \emph{supersequence}.  A supersequence can be computed by processing the nodes of the (acyclic) sequence graph in order. For example, suppose the input sequences are $X$-$Y$, $Y$-$Z$, and $X$-$Z$; then, the resulting supersequence would be $X$-$Y$-$Z$. To generate the tags, Algorithm~\ref{alg:memory_min}
can be used ``as is'' to generate a concise encoding.  The resulting rules in the switches would simply match on the attributes
in the appropriate ``order'', e.g., a rule that checks for attribute $Y$ would include a $0$ bit for $X$, to ensure that middlebox $X$ was already visited and the associated bit in the tag cleared.  We discuss how to compute the rules in more detail in \S~\ref{s:order-rules}.

\subsection{Sequences Forming a Cycle}
Sometimes, there does not exist a supersequence of attributes that all sequences follow its order. This is case  if for two attributes $B, A$,  $B$ appears before $A$ in some sequences, but $A$ appears before $B$ in others. Similarly, this happens when $B$ appear before $A$ in a sequence and $A$ has to appear before $B$ based on transitivity of other attributes. We refer to that as order-inconsistency.  In such cases the graph $G$ contains a cycle. We describe two approaches to deal with this scenario. 

\textbf{Approach I:} The first approach begins with the input sequences. In each step, pairs of supersets are considered as long as their merging does not result in order-inconsistency. A pair is selected based on similar criterions as for the non-ordered sets. Finally, for each superset in the result, an identifier is allocated based on a potential order of the corresponding attributes.

\textbf{Approach II:} The first approach can sometime result in a large number of sequences that cannot be further merged. The second approach is more flexible by allowing the merging of two sequences even if this results in order-inconsistency. We solve the inconsistency by finding a supersequence with multiple appearances of some of the attributes such that merged sequences can be described as subsequences. 

To do so systematically, we construct the sequence graph $G$, shown in \ref{fig:ordering}(b) for the sequences  in \ref{fig:ordering}(a). We then run an algorithm for finding Strongly Connected Components (SCCs) on this graph. A strongly connected component is a set of nodes such that for every pair of nodes $u$ and $v$ in the set, $u$ has a path to $v$ and vice versa. In this context, every SCC corresponds to a set of incomparable elements.  Figure \ref{fig:ordering}(c) shows the result of finding SCCs on the sequence graph, identifying one pair of incomparable elements. Figure \ref{fig:ordering}(d) through (f) shows, at a high level, how the SCC is broken up 

%
%\begin{figure}[t!] 
%\begin{minipage}{1\linewidth}
%\begin{subfigure}[c]{0.96\linewidth}
%\includegraphics[trim={0 6cm 19.2cm 0}, clip, width=\linewidth]{figures/partial_ordering}
%\end{subfigure} 
%\end{minipage} 
%\caption{Not-aligned ordering constraints. (a) shows the four input ordered sequences. In (b) illustrates the corresponding sequence graph $G$.. (b) shows the disjoints SCCs  (Strongly Connected Components) of $G$. Each SCC corresponds to a set of incomparable elements. (d) describes the result of splitting elements to resolve order-inconsistency, which is covered in more depth in figure \ref{fig:conflict_res}. In (e), the original sequences are modified with the splits such that each sequence adheres to the constructed ordering.}
%\label{fig:ordering}
%\end{figure}



%\begin{figure}[t!] 
%\begin{minipage}{1\linewidth}
%\begin{subfigure}[c]{0.96\linewidth}
%\includegraphics[trim={19.2cm 10cm 0 0}, clip, width=\linewidth]{figures/partial_ordering}
%\end{subfigure} 
%\end{minipage} 
%\caption{This details the order-inconsistency resolution step of the algorithm. (a) shows a SCC of four attributes. (b) shows an 'almost' ordering of the SCC nodes, which minimizes the number of backward edges. (c) shows a  construction of a worst-case quadratically-sized universe, which is then traversed by every sequence to determine which attributes to splits for the new ordering.}
%\label{fig:conflict_res}
%\end{figure}

\subsection{Constructing Rules That Respect Order}
\label{s:order-rules}

We have previously shown how to construct tags and match strings for unordered attribute sets. Figure \ref{fig:ordered_rules} shows the process for constructing ordered rules. The process assumes that the input sequences are drawn from a supersequence, so the input to this process is the output of the conflict resolution algorithm shown in Figure \ref{fig:ordering}.

The input sequences are treated as unordered sequences and run through our encoding scheme, to produce a tag for each sequence (Figure \ref{fig:ordered_rules}(b)) and a set of unordered match strings for each attribute (Figure \ref{fig:ordered_rules}(c)) . 
To produce ordered rules from the unordered rules output by the encoding algorithm, we will consider the concrete example of attribute $A$. 

There is a match string for each group that $A$ appears in, where the only non-wildcard bits are for the group ID and the bit position corresponding to $A$. Note that the only attribute which appears before $A$ in the supersequence is $E$, so applying an ordering to these match strings means ensuring they only return true when attribute $E$ is not present. 
 For each match string, if the ID corresponds to a group that $E$ is present in, set the bit position corresponding to $E$ to 0. If $E$ is not present, make no changes. This way, $A$ strings will only return true if either the $E$ bit is not present, or equal to 0. 

\begin{figure*}[t!]
%\begin{minipage}{2\linewidth}
%\begin{subfigure}[c]{0.96\linewidth}
%\includegraphics[trim={0 6cm 19.2cm 0}, clip, width=\linewidth]{figures/partial_ordering}
\includegraphics[trim={0 18cm 0 0}, clip, width=\textwidth]{figures/ordered_match_strings}
%\end{subfigure} 
%\end{minipage} 
\caption{Match strings for ordered versus unordered attributes. (a) shows the set of input sequences which, when treated as unordered sets and run through our encoding algorithm, produce a set of tags in (b). The unordered column of (c) shows the query strings produced for checking each attribute in an unordered fashion. The ordered column is produced by taking the unordered strings and replacing wildcard characters with 0 for every attribute that appears before the current attribute in the ordering.}
\label{fig:ordered_rules}
\end{figure*}
